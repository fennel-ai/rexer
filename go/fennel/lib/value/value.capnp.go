// Code generated by capnpc-go. DO NOT EDIT.

package value

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

type Map capnp.Struct

// Map_TypeID is the unique identifier for the type Map.
const Map_TypeID = 0x9945b8a158dafb52

func NewMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Map(st), err
}

func NewRootMap(s *capnp.Segment) (Map, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Map(st), err
}

func ReadRootMap(msg *capnp.Message) (Map, error) {
	root, err := msg.Root()
	return Map(root.Struct()), err
}

func (s Map) String() string {
	str, _ := text.Marshal(0x9945b8a158dafb52, capnp.Struct(s))
	return str
}

func (s Map) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Map) DecodeFromPtr(p capnp.Ptr) Map {
	return Map(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Map) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Map) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Map) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Map) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Map) Entries() (Map_Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Map_Entry_List(p.List()), err
}

func (s Map) HasEntries() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Map) SetEntries(v Map_Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEntries sets the entries field to a newly
// allocated Map_Entry_List, preferring placement in s's segment.
func (s Map) NewEntries(n int32) (Map_Entry_List, error) {
	l, err := NewMap_Entry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Map_Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Map_List is a list of Map.
type Map_List = capnp.StructList[Map]

// NewMap creates a new list of Map.
func NewMap_List(s *capnp.Segment, sz int32) (Map_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Map](l), err
}

// Map_Future is a wrapper for a Map promised by a client call.
type Map_Future struct{ *capnp.Future }

func (p Map_Future) Struct() (Map, error) {
	s, err := p.Future.Struct()
	return Map(s), err
}

type Map_Entry capnp.Struct

// Map_Entry_TypeID is the unique identifier for the type Map_Entry.
const Map_Entry_TypeID = 0xf5068dc83f96f503

func NewMap_Entry(s *capnp.Segment) (Map_Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Map_Entry(st), err
}

func NewRootMap_Entry(s *capnp.Segment) (Map_Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Map_Entry(st), err
}

func ReadRootMap_Entry(msg *capnp.Message) (Map_Entry, error) {
	root, err := msg.Root()
	return Map_Entry(root.Struct()), err
}

func (s Map_Entry) String() string {
	str, _ := text.Marshal(0xf5068dc83f96f503, capnp.Struct(s))
	return str
}

func (s Map_Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Map_Entry) DecodeFromPtr(p capnp.Ptr) Map_Entry {
	return Map_Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Map_Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Map_Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Map_Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Map_Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Map_Entry) Key() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Map_Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Map_Entry) SetKey(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

func (s Map_Entry) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(1)
}

func (s Map_Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Map_Entry) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(1, v)
}

// Map_Entry_List is a list of Map_Entry.
type Map_Entry_List = capnp.StructList[Map_Entry]

// NewMap_Entry creates a new list of Map_Entry.
func NewMap_Entry_List(s *capnp.Segment, sz int32) (Map_Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Map_Entry](l), err
}

// Map_Entry_Future is a wrapper for a Map_Entry promised by a client call.
type Map_Entry_Future struct{ *capnp.Future }

func (p Map_Entry_Future) Struct() (Map_Entry, error) {
	s, err := p.Future.Struct()
	return Map_Entry(s), err
}

func (p Map_Entry_Future) Key() *capnp.Future {
	return p.Future.Field(0, nil)
}

func (p Map_Entry_Future) Value() *capnp.Future {
	return p.Future.Field(1, nil)
}

type CapnValue capnp.Struct
type CapnValue_Which uint16

const (
	CapnValue_Which_int    CapnValue_Which = 0
	CapnValue_Which_double CapnValue_Which = 1
	CapnValue_Which_bool   CapnValue_Which = 2
	CapnValue_Which_str    CapnValue_Which = 3
	CapnValue_Which_list   CapnValue_Which = 4
	CapnValue_Which_dict   CapnValue_Which = 5
	CapnValue_Which_table  CapnValue_Which = 6
	CapnValue_Which_nil    CapnValue_Which = 7
)

func (w CapnValue_Which) String() string {
	const s = "intdoubleboolstrlistdicttablenil"
	switch w {
	case CapnValue_Which_int:
		return s[0:3]
	case CapnValue_Which_double:
		return s[3:9]
	case CapnValue_Which_bool:
		return s[9:13]
	case CapnValue_Which_str:
		return s[13:16]
	case CapnValue_Which_list:
		return s[16:20]
	case CapnValue_Which_dict:
		return s[20:24]
	case CapnValue_Which_table:
		return s[24:29]
	case CapnValue_Which_nil:
		return s[29:32]

	}
	return "CapnValue_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// CapnValue_TypeID is the unique identifier for the type CapnValue.
const CapnValue_TypeID = 0xf16c838ef80f951a

func NewCapnValue(s *capnp.Segment) (CapnValue, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return CapnValue(st), err
}

func NewRootCapnValue(s *capnp.Segment) (CapnValue, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return CapnValue(st), err
}

func ReadRootCapnValue(msg *capnp.Message) (CapnValue, error) {
	root, err := msg.Root()
	return CapnValue(root.Struct()), err
}

func (s CapnValue) String() string {
	str, _ := text.Marshal(0xf16c838ef80f951a, capnp.Struct(s))
	return str
}

func (s CapnValue) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (CapnValue) DecodeFromPtr(p capnp.Ptr) CapnValue {
	return CapnValue(capnp.Struct{}.DecodeFromPtr(p))
}

func (s CapnValue) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s CapnValue) Which() CapnValue_Which {
	return CapnValue_Which(capnp.Struct(s).Uint16(8))
}
func (s CapnValue) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s CapnValue) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s CapnValue) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s CapnValue) Int() int64 {
	if capnp.Struct(s).Uint16(8) != 0 {
		panic("Which() != int")
	}
	return int64(capnp.Struct(s).Uint64(0))
}

func (s CapnValue) SetInt(v int64) {
	capnp.Struct(s).SetUint16(8, 0)
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s CapnValue) Double() float64 {
	if capnp.Struct(s).Uint16(8) != 1 {
		panic("Which() != double")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s CapnValue) SetDouble(v float64) {
	capnp.Struct(s).SetUint16(8, 1)
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s CapnValue) Bool() bool {
	if capnp.Struct(s).Uint16(8) != 2 {
		panic("Which() != bool")
	}
	return capnp.Struct(s).Bit(0)
}

func (s CapnValue) SetBool(v bool) {
	capnp.Struct(s).SetUint16(8, 2)
	capnp.Struct(s).SetBit(0, v)
}

func (s CapnValue) Str() (string, error) {
	if capnp.Struct(s).Uint16(8) != 3 {
		panic("Which() != str")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s CapnValue) HasStr() bool {
	if capnp.Struct(s).Uint16(8) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s CapnValue) StrBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s CapnValue) SetStr(v string) error {
	capnp.Struct(s).SetUint16(8, 3)
	return capnp.Struct(s).SetText(0, v)
}

func (s CapnValue) List() (CapnValue_List, error) {
	if capnp.Struct(s).Uint16(8) != 4 {
		panic("Which() != list")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return CapnValue_List(p.List()), err
}

func (s CapnValue) HasList() bool {
	if capnp.Struct(s).Uint16(8) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s CapnValue) SetList(v CapnValue_List) error {
	capnp.Struct(s).SetUint16(8, 4)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewList sets the list field to a newly
// allocated CapnValue_List, preferring placement in s's segment.
func (s CapnValue) NewList(n int32) (CapnValue_List, error) {
	capnp.Struct(s).SetUint16(8, 4)
	l, err := NewCapnValue_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return CapnValue_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

func (s CapnValue) Dict() (Map, error) {
	if capnp.Struct(s).Uint16(8) != 5 {
		panic("Which() != dict")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Map(p.Struct()), err
}

func (s CapnValue) HasDict() bool {
	if capnp.Struct(s).Uint16(8) != 5 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s CapnValue) SetDict(v Map) error {
	capnp.Struct(s).SetUint16(8, 5)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewDict sets the dict field to a newly
// allocated Map struct, preferring placement in s's segment.
func (s CapnValue) NewDict() (Map, error) {
	capnp.Struct(s).SetUint16(8, 5)
	ss, err := NewMap(capnp.Struct(s).Segment())
	if err != nil {
		return Map{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s CapnValue) Table() (Map_List, error) {
	if capnp.Struct(s).Uint16(8) != 6 {
		panic("Which() != table")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Map_List(p.List()), err
}

func (s CapnValue) HasTable() bool {
	if capnp.Struct(s).Uint16(8) != 6 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s CapnValue) SetTable(v Map_List) error {
	capnp.Struct(s).SetUint16(8, 6)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTable sets the table field to a newly
// allocated Map_List, preferring placement in s's segment.
func (s CapnValue) NewTable(n int32) (Map_List, error) {
	capnp.Struct(s).SetUint16(8, 6)
	l, err := NewMap_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Map_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

func (s CapnValue) SetNil() {
	capnp.Struct(s).SetUint16(8, 7)

}

// CapnValue_List is a list of CapnValue.
type CapnValue_List = capnp.StructList[CapnValue]

// NewCapnValue creates a new list of CapnValue.
func NewCapnValue_List(s *capnp.Segment, sz int32) (CapnValue_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[CapnValue](l), err
}

// CapnValue_Future is a wrapper for a CapnValue promised by a client call.
type CapnValue_Future struct{ *capnp.Future }

func (p CapnValue_Future) Struct() (CapnValue, error) {
	s, err := p.Future.Struct()
	return CapnValue(s), err
}

func (p CapnValue_Future) Dict() Map_Future {
	return Map_Future{Future: p.Future.Field(0, nil)}
}

const schema_8cfb90d81c574cef = "x\xda\xac\x92\xc1k\x13O\x1c\xc5\xdf\x9b\xd9\xcd\x06\x9a" +
	"mv\xb2\x0b\x85\x1f\xfd\x11-\x82Vh\xa9\xd5\x83\x14" +
	"\xa1\xad\xb5'\x15:\x06\xaa\xd7\xb4\xcd!\xb8lB\xbb" +
	"Uz\x12\x95\x1e\x04\x15/\x8a\x1e\x04\x05\xff\x82\x9e\xfc" +
	"\x0f\xf4\xe0AA!J\x05\x05\xef\xea!\x90\x1a\xeb\xc8" +
	"\xa4\xd84\xd4\xa3\xd7\xefw\xe6\xf3\x1e\xef}\xc7f8" +
	"\xe5\x1c\xf3k\x02B\x0f\xba\x19s\xa1\xfd\xe1\xd2\xd3\xe7" +
	"\xb3\x8f\xa0r4_\xcf]\x1cl\xdck\xdf\x86K/" +
	"`\xf8?o\x84\x079\x00\x84\xc3\x9c\x04\xc2u\x0e\x98" +
	"\xff\xee\xe7[wo\xc6\xdf\xa1s\x14\xdd\x0f\xb3\xf4\xb2" +
	"t\xc2\xeb\xdc\x08o\xd1\x03\x8e\xaf\xf3\x05A#\x9b\x0f" +
	"&_\xde\xc94\xa1\x02v\xb5\\a\xf1[r#\xa4" +
	"\xe3\x01\xe1\xb6\xbc\x8a\x11s\xa5\x1c\xafVF\x17\xcb\xac" +
	"'\xf5\x89\xf3\xe5:\xb4\xc3\xbd\x04\x8e\x17g\x93ty" +
	"M;\xd2\x01\x1c\x02\xca?\x0d\xe8\xac\xa4>)x\xad" +
	"\x92\xa4\xcb\xd5\xca\x0a\xfb\xc19I\x06\xdd\xaf\xc0\x14\x15" +
	"\x8b\xda\x11{L\x90\x80};\x9d\xa5r\x0b\xca-\xf0" +
	",\xe7{M\xcc\x94\xebIq\xdeN\xe6H}@:" +
	"9c:\xbao\x86\x00\xfdJR7\x04}\xfe2\x91" +
	"\x85\xa9w\x13\x80~-\xa97\x05}\xb1m\"\x0a@" +
	"\xbd?\x0a\xe8\xb7\x92\xfa\x93\xa0/\x7f\x9a\x88\x12P\x1f" +
	"-\xa1!\xa9\xbf\x08\xfaN\xdbDt\x00\xf5\xd9\xbe\xdd" +
	"\x94\xd4-A\xdf\xfda\"\xba\x80j\xda\xe97\xc9\xd2" +
	"\x19\x0a\xfa\x99-\x131\x03\x84\xd3\x1c\x07J\xa7(Y" +
	"zb\x17^\xcbD6\xfb\xf01\x87\x80\xd2C\xbbx" +
	"FA\xaf\x9a\xa4t!\xe8\x82\x93K\xb5\xd5\x85\xb8\xc2" +
	">\x08\xf6\x81\xf9\x85Z-&!H\xd0[I\x97\x99" +
	"\x83`\x0e\xcc\xc7\xd5\x95\xb4\x9b\xe4n\xeb\xa0\x1d\xe6\x97" +
	"\xaa\x8b)\x83n\x96\x7f\x0d\x18P<\xac\xb3$i;" +
	"\"u \xd9\x11\xe8\x05\x06`1-[W\xbbz\xff" +
	"\x06\xdc\x0fzI5Ff\xdfi\x8d\xee\\\xd2\\\x07" +
	"\xf0\xe7\x98\x86m%\x87$\xf5\x98\xa0\"w:\x1d\x19" +
	"\x07\xf4\x11I}B\xd0\xbb\\Yc\x81=NX\x00" +
	"\x8b\x1d<\x0b\xee\xfe\xd5\xef\x00\x00\x00\xff\xff\x81\x01\xd8" +
	"\xe5"

func init() {
	schemas.Register(schema_8cfb90d81c574cef,
		0x9945b8a158dafb52,
		0xf16c838ef80f951a,
		0xf5068dc83f96f503)
}
